// src/services/storage/sqlite.js - VERSIÃ“N CON PROMEDIOS DE SEDE
import sqlite3 from 'sqlite3';
import { open } from 'sqlite3';
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

let db = null;

export async function initSQLite() {
    if (db) return db;
    
    try {
        const dataDir = path.join(__dirname, '../../../data');
        if (!fs.existsSync(dataDir)) {
            fs.mkdirSync(dataDir, { recursive: true });
        }
        
        const dbPath = path.join(dataDir, 'history.db');
        console.log(`[SQLite] Inicializando base de datos en: ${dbPath}`);
        
        db = await open({
            filename: dbPath,
            driver: sqlite3.Database
        });
        
        // Tabla de historial de monitores
        await db.exec(`
            CREATE TABLE IF NOT EXISTS monitor_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                monitorId TEXT NOT NULL,
                timestamp INTEGER NOT NULL,
                status TEXT NOT NULL,
                responseTime REAL,
                message TEXT,
                instance TEXT
            );
            
            CREATE INDEX IF NOT EXISTS idx_monitor_time 
            ON monitor_history(monitorId, timestamp);
            
            CREATE INDEX IF NOT EXISTS idx_timestamp 
            ON monitor_history(timestamp);
            
            CREATE INDEX IF NOT EXISTS idx_instance 
            ON monitor_history(instance);
        `);
        
        // ðŸŸ¢ NUEVO: Tabla de promedios por instancia (sede)
        await db.exec(`
            CREATE TABLE IF NOT EXISTS instance_averages (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                instance TEXT NOT NULL,
                timestamp INTEGER NOT NULL,
                avgResponseTime REAL NOT NULL,
                avgStatus REAL NOT NULL,
                monitorCount INTEGER NOT NULL,
                upCount INTEGER NOT NULL,
                downCount INTEGER NOT NULL,
                degradedCount INTEGER NOT NULL,
                createdAt DATETIME DEFAULT CURRENT_TIMESTAMP
            );
            
            CREATE INDEX IF NOT EXISTS idx_instance_time 
            ON instance_averages(instance, timestamp);
            
            CREATE INDEX IF NOT EXISTS idx_instance_timestamp 
            ON instance_averages(timestamp);
        `);
        
        // Tabla de monitores activos
        await db.exec(`
            CREATE TABLE IF NOT EXISTS active_monitors (
                monitorId TEXT PRIMARY KEY,
                instance TEXT NOT NULL,
                lastSeen INTEGER NOT NULL,
                monitorName TEXT,
                firstSeen INTEGER NOT NULL
            );
            
            CREATE INDEX IF NOT EXISTS idx_active_lastSeen 
            ON active_monitors(lastSeen);
            
            CREATE INDEX IF NOT EXISTS idx_active_instance 
            ON active_monitors(instance);
        `);
        
        console.log('[SQLite] âœ… Tablas verificadas/creadas correctamente');
        
        return db;
    } catch (error) {
        console.error('[SQLite] âŒ Error crÃ­tico:', error);
        throw error;
    }
}

export async function ensureSQLite() {
    if (!db) {
        db = await initSQLite();
    }
    return db;
}

// ========== FUNCIONES PARA MONITORES ==========

export async function insertHistory(event) {
    await ensureSQLite();
    
    const { monitorId, timestamp, status, responseTime = null, message = null } = event;
    const instance = monitorId.includes('_') ? monitorId.split('_')[0] : 'unknown';
    const monitorName = monitorId.includes('_') ? monitorId.split('_').slice(1).join('_') : monitorId;
    
    try {
        const result = await db.run(
            `INSERT INTO monitor_history (monitorId, timestamp, status, responseTime, message, instance)
             VALUES (?, ?, ?, ?, ?, ?)`,
            [monitorId, timestamp, status, responseTime, message, instance]
        );
        
        // Actualizar monitores activos
        await db.run(`
            INSERT INTO active_monitors (monitorId, instance, lastSeen, firstSeen, monitorName)
            VALUES (?, ?, ?, ?, ?)
            ON CONFLICT(monitorId) DO UPDATE SET
                lastSeen = excluded.lastSeen,
                instance = excluded.instance,
                monitorName = excluded.monitorName
        `, [monitorId, instance, timestamp, timestamp, monitorName]);
        
        return { id: result.lastID };
    } catch (error) {
        console.error('[SQLite] Error insertando:', error);
        throw error;
    }
}

export async function getHistory(params) {
    await ensureSQLite();
    const { monitorId, from, to, limit = 1000, offset = 0 } = params;
    return await db.all(
        `SELECT * FROM monitor_history
         WHERE monitorId = ? AND timestamp >= ? AND timestamp <= ?
         ORDER BY timestamp DESC LIMIT ? OFFSET ?`,
        [monitorId, from, to, limit, offset]
    );
}

export async function getHistoryAgg(params) {
    await ensureSQLite();
    const { monitorId, from, to, bucketMs = 60000 } = params;
    
    const result = await db.all(
        `SELECT
            CAST((timestamp / ?) * ? AS INTEGER) AS bucket,
            AVG(CASE WHEN status = 'up' THEN 1 ELSE 0 END) as avgStatus,
            AVG(responseTime) as avgResponseTime,
            COUNT(*) as count
         FROM monitor_history
         WHERE monitorId = ? AND timestamp >= ? AND timestamp <= ?
         GROUP BY bucket ORDER BY bucket ASC`,
        [bucketMs, bucketMs, monitorId, from, to]
    );
    
    return result.map(row => ({
        timestamp: row.bucket,
        avgStatus: row.avgStatus,
        avgResponseTime: row.avgResponseTime || 0,
        count: row.count
    }));
}

// ========== ðŸŸ¢ FUNCIONES PARA PROMEDIOS DE INSTANCIA ==========

export async function calculateInstanceAverage(instanceName, timestamp = Date.now()) {
    await ensureSQLite();
    
    const from = timestamp - (5 * 60 * 1000); // Ãšltimos 5 minutos
    const to = timestamp;
    
    try {
        // Obtener todos los monitores de la instancia en los Ãºltimos 5 minutos
        const monitors = await db.all(`
            SELECT 
                monitorId,
                AVG(responseTime) as avgResponseTime,
                AVG(CASE WHEN status = 'up' THEN 1 ELSE 0 END) as avgStatus,
                COUNT(*) as samples
            FROM monitor_history
            WHERE instance = ? 
                AND timestamp >= ? 
                AND timestamp <= ?
                AND responseTime IS NOT NULL
            GROUP BY monitorId
        `, [instanceName, from, to]);
        
        if (monitors.length === 0) {
            console.log(`[SQLite] No hay datos para calcular promedio de ${instanceName}`);
            return null;
        }
        
        // Calcular promedios generales
        let totalResponseTime = 0;
        let totalStatus = 0;
        let validResponseCount = 0;
        let upCount = 0;
        let downCount = 0;
        let degradedCount = 0;
        
        for (const m of monitors) {
            if (m.avgResponseTime > 0) {
                totalResponseTime += m.avgResponseTime;
                validResponseCount++;
            }
            totalStatus += m.avgStatus;
            
            // Contar estados (aproximado)
            if (m.avgStatus > 0.8) upCount++;
            else if (m.avgStatus < 0.2) downCount++;
            else degradedCount++;
        }
        
        const avgResponseTime = validResponseCount > 0 ? totalResponseTime / validResponseCount : 0;
        const avgStatus = totalStatus / monitors.length;
        
        // Insertar el promedio
        const result = await db.run(`
            INSERT INTO instance_averages 
                (instance, timestamp, avgResponseTime, avgStatus, monitorCount, upCount, downCount, degradedCount)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `, [
            instanceName, 
            timestamp, 
            avgResponseTime, 
            avgStatus, 
            monitors.length,
            upCount,
            downCount,
            degradedCount
        ]);
        
        console.log(`[SQLite] âœ… Promedio calculado para ${instanceName}: ${Math.round(avgResponseTime)}ms (${monitors.length} monitores)`);
        
        return {
            instance: instanceName,
            timestamp,
            avgResponseTime,
            avgStatus,
            monitorCount: monitors.length,
            upCount,
            downCount,
            degradedCount
        };
    } catch (error) {
        console.error(`[SQLite] Error calculando promedio para ${instanceName}:`, error);
        return null;
    }
}

export async function calculateAllInstanceAverages() {
    await ensureSQLite();
    
    try {
        // Obtener todas las instancias con monitores activos
        const instances = await db.all(`
            SELECT DISTINCT instance FROM active_monitors
            WHERE lastSeen > ?
        `, [Date.now() - (10 * 60 * 1000)]); // Ãšltimos 10 minutos
        
        console.log(`[SQLite] Calculando promedios para ${instances.length} instancias...`);
        
        const results = [];
        for (const row of instances) {
            const result = await calculateInstanceAverage(row.instance);
            if (result) results.push(result);
        }
        
        console.log(`[SQLite] âœ… Promedios calculados para ${results.length} instancias`);
        return results;
    } catch (error) {
        console.error('[SQLite] Error calculando promedios:', error);
        return [];
    }
}

export async function getInstanceAverage(instanceName, sinceMs = 60 * 60 * 1000) {
    await ensureSQLite();
    
    const from = Date.now() - sinceMs;
    const to = Date.now();
    
    try {
        const averages = await db.all(`
            SELECT * FROM instance_averages
            WHERE instance = ? 
                AND timestamp >= ? 
                AND timestamp <= ?
            ORDER BY timestamp ASC
        `, [instanceName, from, to]);
        
        return averages;
    } catch (error) {
        console.error(`[SQLite] Error obteniendo promedios para ${instanceName}:`, error);
        return [];
    }
}

export async function getLatestInstanceAverage(instanceName) {
    await ensureSQLite();
    
    try {
        const average = await db.get(`
            SELECT * FROM instance_averages
            WHERE instance = ?
            ORDER BY timestamp DESC
            LIMIT 1
        `, [instanceName]);
        
        return average;
    } catch (error) {
        console.error(`[SQLite] Error obteniendo Ãºltimo promedio para ${instanceName}:`, error);
        return null;
    }
}

// ========== FUNCIONES EXISTENTES ==========

export async function getAvailableMonitors() {
    await ensureSQLite();
    
    try {
        await cleanupInactiveMonitors(10);
        
        return await db.all(`
            SELECT 
                am.monitorId,
                am.instance,
                am.lastSeen,
                am.firstSeen,
                am.monitorName,
                COUNT(h.id) as totalChecks,
                AVG(CASE WHEN h.status = 'up' THEN 1.0 ELSE 0.0 END) * 100 as uptimePercent,
                AVG(h.responseTime) as avgResponseTime
            FROM active_monitors am
            LEFT JOIN monitor_history h ON h.monitorId = am.monitorId 
                AND h.timestamp >= am.lastSeen - 86400000
            GROUP BY am.monitorId
            ORDER BY am.lastSeen DESC
        `);
    } catch (error) {
        console.error('[SQLite] Error obteniendo monitores:', error);
        return [];
    }
}

export async function getMonitorsByInstance(instanceName, hours = 24) {
    await ensureSQLite();
    
    try {
        const from = Date.now() - (hours * 60 * 60 * 1000);
        const to = Date.now();
        
        await cleanupInactiveMonitors(10);
        
        return await db.all(`
            SELECT 
                am.monitorId,
                am.monitorName,
                am.lastSeen,
                COUNT(h.id) as totalChecks,
                AVG(CASE WHEN h.status = 'up' THEN 1.0 ELSE 0.0 END) * 100 as uptimePercent,
                AVG(h.responseTime) as avgResponseTime
            FROM active_monitors am
            LEFT JOIN monitor_history h ON h.monitorId = am.monitorId 
                AND h.timestamp >= ? 
                AND h.timestamp <= ?
            WHERE am.instance = ?
            GROUP BY am.monitorId
            ORDER BY am.lastSeen DESC
        `, [from, to, instanceName]);
    } catch (error) {
        console.error('[SQLite] Error obteniendo monitores por instancia:', error);
        return [];
    }
}

export async function cleanupInactiveMonitors(olderThanMinutes = 10) {
    await ensureSQLite();
    
    try {
        const threshold = Date.now() - (olderThanMinutes * 60 * 1000);
        
        const result = await db.run(
            `DELETE FROM active_monitors WHERE lastSeen < ?`,
            [threshold]
        );
        
        if (result.changes > 0) {
            console.log(`[SQLite] ðŸ§¹ Limpieza: ${result.changes} monitores inactivos eliminados`);
        }
        
        return result.changes || 0;
    } catch (error) {
        console.error('[SQLite] Error en limpieza:', error);
        return 0;
    }
}

export async function markMonitorsInactive(activeMonitorIds) {
    await ensureSQLite();
    
    try {
        const threshold = Date.now() - (10 * 60 * 1000);
        
        if (activeMonitorIds && activeMonitorIds.length > 0) {
            const placeholders = activeMonitorIds.map(() => '?').join(',');
            const result = await db.run(
                `DELETE FROM active_monitors 
                 WHERE lastSeen < ? 
                   AND monitorId NOT IN (${placeholders})`,
                [threshold, ...activeMonitorIds]
            );
            
            if (result.changes > 0) {
                console.log(`[SQLite] ðŸ§¹ Marcados ${result.changes} monitores como inactivos`);
            }
            return result.changes;
        }
        return 0;
    } catch (error) {
        console.error('[SQLite] Error marcando inactivos:', error);
        return 0;
    }
}
